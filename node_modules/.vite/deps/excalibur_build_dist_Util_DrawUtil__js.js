import "./chunk-Y2F7D3TJ.js";

// node_modules/excalibur/build/dist/Color.js
var Color = class _Color {
  /**
   * Creates a new instance of Color from an r, g, b, a
   * @param r  The red component of color (0-255)
   * @param g  The green component of color (0-255)
   * @param b  The blue component of color (0-255)
   * @param a  The alpha component of color (0-1.0)
   */
  constructor(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a != null ? a : 1;
  }
  /**
   * Creates a new instance of Color from an r, g, b, a
   * @param r  The red component of color (0-255)
   * @param g  The green component of color (0-255)
   * @param b  The blue component of color (0-255)
   * @param a  The alpha component of color (0-1.0)
   */
  static fromRGB(r, g, b, a) {
    return new _Color(r, g, b, a);
  }
  /**
   * Creates a new instance of Color from a rgb string
   * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
   */
  static fromRGBString(string) {
    const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
    let match = null;
    if (match = string.match(rgbaRegEx)) {
      const r = parseInt(match[1], 10);
      const g = parseInt(match[2], 10);
      const b = parseInt(match[3], 10);
      let a = 1;
      if (match[4]) {
        a = parseFloat(match[4]);
      }
      return new _Color(r, g, b, a);
    } else {
      throw new Error("Invalid rgb/a string: " + string);
    }
  }
  /**
   * Creates a new instance of Color from a hex string
   * @param hex  CSS color string of the form #ffffff, the alpha component is optional
   */
  static fromHex(hex) {
    const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
    let match = null;
    if (match = hex.match(hexRegEx)) {
      const r = parseInt(match[1], 16);
      const g = parseInt(match[2], 16);
      const b = parseInt(match[3], 16);
      let a = 1;
      if (match[4]) {
        a = parseInt(match[4], 16) / 255;
      }
      return new _Color(r, g, b, a);
    } else {
      throw new Error("Invalid hex string: " + hex);
    }
  }
  /**
   * Creates a new instance of Color from hsla values
   * @param h  Hue is represented [0-1]
   * @param s  Saturation is represented [0-1]
   * @param l  Luminance is represented [0-1]
   * @param a  Alpha is represented [0-1]
   */
  static fromHSL(h, s, l, a = 1) {
    const temp = new HSLColor(h, s, l, a);
    return temp.toRGBA();
  }
  /**
   * Lightens the current color by a specified amount
   * @param factor  The amount to lighten by [0-1]
   */
  lighten(factor = 0.1) {
    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
    temp.l += (1 - temp.l) * factor;
    return temp.toRGBA();
  }
  /**
   * Darkens the current color by a specified amount
   * @param factor  The amount to darken by [0-1]
   */
  darken(factor = 0.1) {
    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
    temp.l -= temp.l * factor;
    return temp.toRGBA();
  }
  /**
   * Saturates the current color by a specified amount
   * @param factor  The amount to saturate by [0-1]
   */
  saturate(factor = 0.1) {
    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
    temp.s += temp.s * factor;
    return temp.toRGBA();
  }
  /**
   * Desaturates the current color by a specified amount
   * @param factor  The amount to desaturate by [0-1]
   */
  desaturate(factor = 0.1) {
    const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
    temp.s -= temp.s * factor;
    return temp.toRGBA();
  }
  /**
   * Multiplies a color by another, results in a darker color
   * @param color  The other color
   */
  multiply(color) {
    const newR = color.r / 255 * this.r / 255 * 255;
    const newG = color.g / 255 * this.g / 255 * 255;
    const newB = color.b / 255 * this.b / 255 * 255;
    const newA = color.a * this.a;
    return new _Color(newR, newG, newB, newA);
  }
  /**
   * Screens a color by another, results in a lighter color
   * @param color  The other color
   */
  screen(color) {
    const color1 = color.invert();
    const color2 = color.invert();
    return color1.multiply(color2).invert();
  }
  /**
   * Inverts the current color
   */
  invert() {
    return new _Color(255 - this.r, 255 - this.g, 255 - this.b, 1 - this.a);
  }
  /**
   * Averages the current color with another
   * @param color  The other color
   */
  average(color) {
    const newR = (color.r + this.r) / 2;
    const newG = (color.g + this.g) / 2;
    const newB = (color.b + this.b) / 2;
    const newA = (color.a + this.a) / 2;
    return new _Color(newR, newG, newB, newA);
  }
  equal(color) {
    return this.toString() === color.toString();
  }
  /**
   * Returns a CSS string representation of a color.
   * @param format Color representation, accepts: rgb, hsl, or hex
   */
  toString(format = "rgb") {
    switch (format) {
      case "rgb":
        return this.toRGBA();
      case "hsl":
        return this.toHSLA();
      case "hex":
        return this.toHex();
      default:
        throw new Error("Invalid Color format");
    }
  }
  /**
   * Returns Hex Value of a color component
   * @param c color component
   * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
   */
  _componentToHex(c) {
    const hex = Math.max(Math.round(c), 0).toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }
  /**
   * Return Hex representation of a color.
   */
  toHex() {
    let hexRepresentation = "#" + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    if (this.a !== 1) {
      hexRepresentation += this._componentToHex(this.a * 255);
    }
    return hexRepresentation;
  }
  /**
   * Return RGBA representation of a color.
   */
  toRGBA() {
    const result = String(this.r.toFixed(0)) + ", " + String(this.g.toFixed(0)) + ", " + String(this.b.toFixed(0));
    if (this.a !== void 0 || this.a !== null) {
      return "rgba(" + result + ", " + String(this.a) + ")";
    }
    return "rgb(" + result + ")";
  }
  /**
   * Return HSLA representation of a color.
   */
  toHSLA() {
    return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
  }
  /**
   * Returns a CSS string representation of a color.
   */
  fillStyle() {
    return this.toString();
  }
  /**
   * Returns a clone of the current color.
   */
  clone() {
    return new _Color(this.r, this.g, this.b, this.a);
  }
  /**
   * Black (#000000)
   */
  static get Black() {
    return _Color.fromHex("#000000");
  }
  /**
   * White (#FFFFFF)
   */
  static get White() {
    return _Color.fromHex("#FFFFFF");
  }
  /**
   * Gray (#808080)
   */
  static get Gray() {
    return _Color.fromHex("#808080");
  }
  /**
   * Light gray (#D3D3D3)
   */
  static get LightGray() {
    return _Color.fromHex("#D3D3D3");
  }
  /**
   * Dark gray (#A9A9A9)
   */
  static get DarkGray() {
    return _Color.fromHex("#A9A9A9");
  }
  /**
   * Yellow (#FFFF00)
   */
  static get Yellow() {
    return _Color.fromHex("#FFFF00");
  }
  /**
   * Orange (#FFA500)
   */
  static get Orange() {
    return _Color.fromHex("#FFA500");
  }
  /**
   * Red (#FF0000)
   */
  static get Red() {
    return _Color.fromHex("#FF0000");
  }
  /**
   * Vermilion (#FF5B31)
   */
  static get Vermilion() {
    return _Color.fromHex("#FF5B31");
  }
  /**
   * Rose (#FF007F)
   */
  static get Rose() {
    return _Color.fromHex("#FF007F");
  }
  /**
   * Magenta (#FF00FF)
   */
  static get Magenta() {
    return _Color.fromHex("#FF00FF");
  }
  /**
   * Violet (#7F00FF)
   */
  static get Violet() {
    return _Color.fromHex("#7F00FF");
  }
  /**
   * Blue (#0000FF)
   */
  static get Blue() {
    return _Color.fromHex("#0000FF");
  }
  /**
   * Azure (#007FFF)
   */
  static get Azure() {
    return _Color.fromHex("#007FFF");
  }
  /**
   * Cyan (#00FFFF)
   */
  static get Cyan() {
    return _Color.fromHex("#00FFFF");
  }
  /**
   * Viridian (#59978F)
   */
  static get Viridian() {
    return _Color.fromHex("#59978F");
  }
  /**
   * Green (#00FF00)
   */
  static get Green() {
    return _Color.fromHex("#00FF00");
  }
  /**
   * Chartreuse (#7FFF00)
   */
  static get Chartreuse() {
    return _Color.fromHex("#7FFF00");
  }
  /**
   * Transparent (#FFFFFF00)
   */
  static get Transparent() {
    return _Color.fromHex("#FFFFFF00");
  }
  /**
   * ExcaliburBlue (#176BAA)
   */
  static get ExcaliburBlue() {
    return _Color.fromHex("#176BAA");
  }
};
var HSLColor = class _HSLColor {
  constructor(h, s, l, a) {
    this.h = h;
    this.s = s;
    this.l = l;
    this.a = a;
  }
  static hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }
  static fromRGBA(r, g, b, a) {
    r /= 255;
    g /= 255;
    b /= 255;
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s;
    const l = (max + min) / 2;
    if (max === min) {
      h = s = 0;
    } else {
      const d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
      }
      h /= 6;
    }
    return new _HSLColor(h, s, l, a);
  }
  toRGBA() {
    let r, g, b;
    if (this.s === 0) {
      r = g = b = this.l;
    } else {
      const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
      const p = 2 * this.l - q;
      r = _HSLColor.hue2rgb(p, q, this.h + 1 / 3);
      g = _HSLColor.hue2rgb(p, q, this.h);
      b = _HSLColor.hue2rgb(p, q, this.h - 1 / 3);
    }
    return new Color(r * 255, g * 255, b * 255, this.a);
  }
  toString() {
    const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
    return `hsla(${h}, ${s}, ${l}, ${a})`;
  }
};

// node_modules/excalibur/build/dist/Util/DrawUtil.js
function line(ctx, color = Color.Red, x1, y1, x2, y2, thickness = 1, cap = "butt") {
  ctx.save();
  ctx.beginPath();
  ctx.lineWidth = thickness;
  ctx.lineCap = cap;
  ctx.strokeStyle = color.toString();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}
function point(ctx, color = Color.Red, point2) {
  ctx.beginPath();
  ctx.strokeStyle = color.toString();
  ctx.arc(point2.x, point2.y, 5, 0, Math.PI * 2);
  ctx.closePath();
  ctx.stroke();
}
function vector(ctx, color, origin, vector2, scale = 1) {
  const c = color ? color.toString() : "blue";
  const v = vector2.scale(scale);
  ctx.beginPath();
  ctx.strokeStyle = c;
  ctx.moveTo(origin.x, origin.y);
  ctx.lineTo(origin.x + v.x, origin.y + v.y);
  ctx.closePath();
  ctx.stroke();
}
function roundRect(ctx, x, y, width, height, radius = 5, stroke = Color.White, fill = null) {
  let br;
  if (typeof radius === "number") {
    br = { tl: radius, tr: radius, br: radius, bl: radius };
  } else {
    const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
    for (const prop in defaultRadius) {
      if (defaultRadius.hasOwnProperty(prop)) {
        const side = prop;
        br[side] = radius[side] || defaultRadius[side];
      }
    }
  }
  ctx.beginPath();
  ctx.moveTo(x + br.tl, y);
  ctx.lineTo(x + width - br.tr, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
  ctx.lineTo(x + width, y + height - br.br);
  ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
  ctx.lineTo(x + br.bl, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
  ctx.lineTo(x, y + br.tl);
  ctx.quadraticCurveTo(x, y, x + br.tl, y);
  ctx.closePath();
  if (fill) {
    ctx.fillStyle = fill.toString();
    ctx.fill();
  }
  if (stroke) {
    ctx.strokeStyle = stroke.toString();
    ctx.stroke();
  }
}
function circle(ctx, x, y, radius, stroke = Color.White, fill = null) {
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI * 2);
  ctx.closePath();
  if (fill) {
    ctx.fillStyle = fill.toString();
    ctx.fill();
  }
  if (stroke) {
    ctx.strokeStyle = stroke.toString();
    ctx.stroke();
  }
}
export {
  circle,
  line,
  point,
  roundRect,
  vector
};
//# sourceMappingURL=excalibur_build_dist_Util_DrawUtil__js.js.map
